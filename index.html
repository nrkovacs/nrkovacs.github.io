<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Crunch of Champions</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #add8e6; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display:block;
            color: white;
            font-family: monospace;
            font-size: 20px;
        }
        #win-message, #lose-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: white;
            background-color: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
            display: none; /* Hidden by default */
            font-family: monospace;
            text-align: center;
        }
        #timer-info {
            position: absolute;
            top: 40px;
            left: 10px;
            color: white;
            font-family: monospace;
            font-size: 18px;
        }
        #fastest-time-info {
            position: absolute;
            top: 60px;
            left: 10px;
            color: white;
            font-family: monospace;
            font-size: 18px;
        }
        #record-message {
            position: absolute;
            top: 40%; /* Moved higher to avoid overlap */
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            color: gold;
            background-color: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            display: none;
            font-family: monospace;
            text-align: center;
            z-index: 110;
        }
        #record-message {
            position: absolute;
            top: 30%; /* Moved higher (was 40%) */
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            color: gold;
            background-color: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            display: none;
            font-family: monospace;
            text-align: center;
            z-index: 110;
        }
        #highscore-info {
            position: absolute;
            top: 40px;
            right: 10px;
            color: white;
            font-family: monospace;
            font-size: 16px;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            text-align: right;
        }
        /* Mobile UI elements */
        #mobile-controls-info {
            position: absolute;
            bottom: 130px; /* Move up to make space for joystick */
            left: 10px;
            color: white;
            font-family: monospace;
            font-size: 14px;
            background-color: rgba(0,0,0,0.5);
            padding: 8px;
            border-radius: 5px;
            z-index: 100;
            pointer-events: none;
        }
        #mouse-controls-info {
            position: absolute;
            bottom: 130px; /* Move up */
            left: 10px;
            color: white;
            font-family: monospace;
            font-size: 14px;
            background-color: rgba(0,0,0,0.5);
            padding: 8px;
            border-radius: 5px;
            z-index: 100;
            pointer-events: none;
        }
        /* On-screen mobile controls */
        #joystick-base {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 150px; /* Increased size */
            height: 150px; /* Increased size */
            background-color: rgba(128, 128, 128, 0.5);
            border-radius: 50%;
            display: none; /* Hidden by default */
            z-index: 101;
        }
        #joystick-nub {
            position: absolute;
            width: 60px; /* Increased size */
            height: 60px; /* Increased size */
            background-color: rgba(200, 200, 200, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; /* Nub doesn't capture events */
        }
        #jump-button {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 100px; /* Increased size */
            height: 100px; /* Increased size */
            background-color: rgba(0, 200, 0, 0.6);
            border-radius: 50%;
            display: none; /* Hidden by default */
            z-index: 101;
            text-align: center;
            line-height: 100px; /* Match height */
            color: white;
            font-size: 24px; /* Slightly larger text */
            font-family: monospace;
            font-weight: bold;
            /* Prevent text selection on mobile */
            -webkit-user-select: none; /* Safari */
            user-select: none;
        }
        #restart-button {
            position: absolute;
            top: 65%; /* Position below win/lose message */
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            font-size: 24px;
            color: white;
            background-color: rgba(200, 0, 0, 0.8); /* Red background */
            border: none;
            border-radius: 8px;
            display: none; /* Hidden by default */
            font-family: monospace;
            font-weight: bold;
            cursor: pointer; /* Indicate it's clickable */
            z-index: 105; /* Above other messages */
        }

        /* --- Media Queries for Responsive Layout --- */

        /* Phones in Portrait (e.g., iPhone Pro, Pixel Pro) */
        @media (max-width: 767px) and (orientation: portrait) {
            #joystick-base {
                width: 120px; /* Slightly smaller than previous increase */
                height: 120px;
                bottom: 15px;
                left: 15px;
            }
            #joystick-nub {
                width: 50px;
                height: 50px;
            }
            #jump-button {
                width: 90px;
                height: 90px;
                bottom: 25px;
                right: 25px;
                line-height: 90px;
                font-size: 20px;
            }
            #timer-info, #fastest-time-info {
                font-size: 14px;
            }
            #highscore-info {
                font-size: 12px;
                padding: 8px;
                max-width: 120px; /* Prevent excessive width */
            }
            #mobile-controls-info, #mouse-controls-info {
                bottom: 160px; /* Adjust based on new joystick size */
                font-size: 12px;
            }
            #win-message, #lose-message {
                font-size: 36px;
            }
            #record-message {
                 font-size: 28px;
             }
             #restart-button {
                 padding: 12px 25px;
                 font-size: 20px;
             }
        }

        /* Tablets (Optional - adjust if needed, inherits desktop/base styles otherwise) */
        /* @media (min-width: 768px) and (max-width: 1024px) { ... } */

    </style>
</head>
<body>
    <div id="info">Crunch of Champions</div>
    <div id="win-message">You Won!</div>
    <div id="lose-message">You Lost!</div>
    <div id="mobile-controls-info">
        Left: Joystick<br>
        Right: Jump/Float
    </div>
    <div id="mouse-controls-info">
        WASD/Arrows: Move<br>
        Space/Shift: Jump
    </div>
    <div id="timer-info">
        Time: <span id="current-time">0.00</span>s
    </div>
    <div id="fastest-time-info">
        Fastest: <span id="fastest-time">-.--</span>s
    </div>
    <div id="record-message">
        New Guinness World Record!
    </div>
    <div id="highscore-info">
        High Scores:<br>
        <ol id="highscore-list" style="list-style-position: inside; padding-left: 0; margin-top: 5px;"></ol>
    </div>
    <!-- Mobile Control Elements -->
    <div id="joystick-base">
        <div id="joystick-nub"></div>
    </div>
    <div id="jump-button">JUMP</div>
    <div id="debug-text"></div>
    <button id="restart-button">Restart</button>
    <!-- Confetti Library -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';

        let scene, camera, renderer;
        let player, bowl, milk, spoon;
        let platforms = [];
        let startPlatform, finishPlatform;
        let keys = {};
        let playerVelocity = new THREE.Vector3();
        let gravity = -0.01;
        let jumpStrength = 0.3; // Increased jump height by 50%
        let playerSpeed = 0.05;
        let onGround = false;
        let gameOver = false;
        let gameWon = false;
        let jumpsRemaining = 0; // For double jump
        let jumpKeyDown = false; // Prevent holding space for multi-jump
        const playerFeetOffset = 0.9; // Distance from player origin (torso center) to feet
        let shadowMesh; // For player shadow
        let raycaster = new THREE.Raycaster(); // For shadow positioning
        let wasOnGround = false; // Track ground state from previous frame
        const coyoteTimeDuration = 0.1; // Seconds player can jump after leaving platform
        let coyoteTimeRemaining = 0;

        // Timer and High Score Variables
        let startTime = 0;
        let timerActive = false;
        let fastestTime = localStorage.getItem('coc_fastestTime') ? parseFloat(localStorage.getItem('coc_fastestTime')) : Infinity;
        let highScores = localStorage.getItem('coc_highScores') ? JSON.parse(localStorage.getItem('coc_highScores')) : [];
        const MAX_HIGH_SCORES = 5;
        let debugMode = false; // for debugging - set to true to see collision information
        let debugText = document.createElement('div');

        // Control variables
        let isMobile = false;
        let moveDirection = new THREE.Vector3(0, 0, 0);
        let jumpButtonPressed = false;
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        let joystickCurrent = { x: 0, y: 0 };
        // let joystickRadius = 75; // Pixel radius - Will be set dynamically
        let joystickTouchId = null; // ID of the touch controlling the joystick
        let jumpButtonTouchId = null; // ID of the touch controlling the jump button
        let floatFactor = 0.3; // How much gravity is reduced when floating (0 = no gravity, 1 = normal) - Reduced for stronger float

        debugText.style.position = 'absolute';
        debugText.style.bottom = '10px';
        debugText.style.left = '10px';
        debugText.style.color = 'white';
        debugText.style.fontFamily = 'monospace';
        debugText.style.zIndex = '1000';
        document.body.appendChild(debugText);

        const winMessage = document.getElementById('win-message');
        const loseMessage = document.getElementById('lose-message');
        const recordMessage = document.getElementById('record-message');
        const currentTimeDisplay = document.getElementById('current-time');
        const fastestTimeDisplay = document.getElementById('fastest-time');
        const highScoreListDisplay = document.getElementById('highscore-list');
        const restartButton = document.getElementById('restart-button');

        let aspect = window.innerWidth / window.innerHeight;
        let d = 20; // Base camera view dimension

        const joystickBase = document.getElementById('joystick-base');
        const joystickNub = document.getElementById('joystick-nub');
        const jumpButton = document.getElementById('jump-button');

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xadd8e6); // Light blue background

            // Camera (Orthographic for Isometric View)
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
            camera.position.set(20, 20, 20); // Isometric position
            camera.lookAt(scene.position);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: false }); // Use false for pixelated look if desired, true for smoother
            renderer.setSize(window.innerWidth, window.innerHeight);
            // renderer.setPixelRatio(window.devicePixelRatio * 0.5); // Optional: Lower resolution for more pixelation
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xcccccc, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // Adjust camera for mobile potentially
            adjustCameraForMobile();

            // Game Elements
            createBowl();
            createMilk();
            createPlatforms(); // Create platforms BEFORE player
            createPlayer(); // Now player can be placed on start platform
            createShadow(); // Create the shadow
            createSpoon();

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);

            // Detect mobile and add touch event listeners
            detectMobile();
            if (isMobile) {
                document.getElementById('mobile-controls-info').style.display = 'block';
                document.getElementById('mouse-controls-info').style.display = 'none';

                // Show and setup joystick/button listeners
                joystickBase.style.display = 'block';
                jumpButton.style.display = 'block';
                /* Remove individual listeners
                joystickBase.addEventListener('touchstart', handleJoystickStart, false);
                joystickBase.addEventListener('touchmove', handleJoystickMove, { passive: false });
                joystickBase.addEventListener('touchend', handleJoystickEnd, false);
                jumpButton.addEventListener('touchstart', handleJumpButtonDown, false);
                jumpButton.addEventListener('touchend', handleJumpButtonUp, false);
                // Add global touchend listener to catch joystick release if finger slides off
                window.addEventListener('touchend', handleGlobalTouchEnd, false);
                */

                // Add global listeners for multi-touch
                window.addEventListener('touchstart', handleTouchStart, false);
                window.addEventListener('touchmove', handleTouchMove, { passive: false });
                window.addEventListener('touchend', handleTouchEnd, false);
                window.addEventListener('touchcancel', handleTouchEnd, false); // Handle cancellation too

                // Add restart button listener for mobile
                restartButton.addEventListener('touchstart', () => {
                    if (gameOver || gameWon) {
                        restartGame();
                    }
                }, false);
            } else {
                document.getElementById('mobile-controls-info').style.display = 'none';
                document.getElementById('mouse-controls-info').style.display = 'block';

                // Hide mobile controls on desktop
                joystickBase.style.display = 'none';
                jumpButton.style.display = 'none';
            }

            // Initial display load for high scores
            updateHighScoreDisplay();

            // Start game loop
            animate();
            // Start timer and ensure player is positioned
            resetGameStartConditions();
        }

         function resetGameStartConditions() {
            // Place player on start platform
            if (player && startPlatform) {
                 player.position.set(
                     startPlatform.position.x,
                     startPlatform.position.y + playerFeetOffset + 0.20, // Ensure correct start height
                     startPlatform.position.z
                 );
                 playerVelocity.set(0, 0, 0);
                 onGround = false; // Start airborne slightly
                 jumpsRemaining = 2;
                 jumpKeyDown = false;
            }

             // Reset game state flags
             gameOver = false;
             gameWon = false;
             winMessage.style.display = 'none';
             loseMessage.style.display = 'none';
             recordMessage.style.display = 'none';
             restartButton.style.display = 'none'; // Hide restart button
             moveDirection.set(0, 0, 0); // Reset move direction
             if (isMobile) {
                 resetJoystick();
                 jumpButtonPressed = false;
             }

             // Reset spoon position
             if (spoon) {
                  spoon.position.set(15, 5, 0);
             }

             // Start timer
             startTime = performance.now();
             timerActive = true;
             currentTimeDisplay.textContent = '0.00';
         }

        // Function to create a procedural texture resembling Cinnamon Toast Crunch
        function createCerealTexture() {
            const canvas = document.createElement('canvas');
            const size = 128; // Texture resolution
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // Base color (light brown/beige)
            ctx.fillStyle = '#D2B48C'; // Tan color
            ctx.fillRect(0, 0, size, size);

            // Add cinnamon swirls/speckles
            ctx.fillStyle = 'rgba(139, 69, 19, 0.6)'; // SaddleBrown with some transparency
            for (let i = 0; i < 80; i++) { // Number of speckles/swirl parts
                const x = Math.random() * size;
                const y = Math.random() * size;
                const swirlSize = Math.random() * 5 + 2;
                ctx.beginPath();
                ctx.arc(x, y, swirlSize, 0, Math.PI * 2);
                ctx.fill();
            }

             // Add sugary glitter (lighter speckles)
             ctx.fillStyle = 'rgba(255, 250, 230, 0.7)'; // Lighter, almost white
             for (let i = 0; i < 150; i++) { // More sugary speckles
                 const x = Math.random() * size;
                 const y = Math.random() * size;
                 const speckleSize = Math.random() * 1.5 + 0.5;
                 ctx.fillRect(x, y, speckleSize, speckleSize);
             }


            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(1, 1); // Adjust tiling if needed
            return texture;
        }


        function detectMobile() {
            // Check if the device is likely a mobile device
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            
            // Regular expressions to check for mobile devices
            const regexes = [
                /Android/i,
                /webOS/i,
                /iPhone/i,
                /iPad/i,
                /iPod/i,
                /BlackBerry/i,
                /Windows Phone/i,
                /Mobile/i,
                /Tablet/i
            ];
            
            // Check if any mobile device pattern matches
            isMobile = regexes.some(regex => regex.test(userAgent));
            
            // Also consider touch-enabled devices as mobile
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                isMobile = true;
            }
            
            return isMobile;
        }

        function createPlayer() {
            player = new THREE.Group();

           const headSize = 0.4;
           const torsoHeight = 0.6;
           const torsoWidth = 0.4;
           const limbWidth = 0.2;
           const armHeight = 0.6;
           const legHeight = 0.6;

           // Materials
           const skinMat = new THREE.MeshLambertMaterial({ color: 0xFFDBAC }); // Skin
           const shirtMat = new THREE.MeshLambertMaterial({ color: 0x00AAAA }); // Cyan shirt
           const pantsMat = new THREE.MeshLambertMaterial({ color: 0x0000AA }); // Blue pants

           // Head
           const headGeo = new THREE.BoxGeometry(headSize, headSize, headSize);
           const head = new THREE.Mesh(headGeo, skinMat);
           head.position.y = (torsoHeight / 2) + (headSize / 2);
           player.add(head);

           // Torso
           const torsoGeo = new THREE.BoxGeometry(torsoWidth, torsoHeight, limbWidth); // Torso depth = limb width
           const torso = new THREE.Mesh(torsoGeo, shirtMat);
           torso.position.y = 0;
           player.add(torso);

           // Arms
           const armGeo = new THREE.BoxGeometry(limbWidth, armHeight, limbWidth);
           const leftArm = new THREE.Mesh(armGeo, skinMat); // Use skin for arms too
           leftArm.position.set(-(torsoWidth / 2 + limbWidth / 2), 0, 0);
           player.add(leftArm);
           const rightArm = new THREE.Mesh(armGeo, skinMat);
           rightArm.position.set(torsoWidth / 2 + limbWidth / 2, 0, 0);
           player.add(rightArm);

           // Legs
           const legGeo = new THREE.BoxGeometry(limbWidth, legHeight, limbWidth);
           const leftLeg = new THREE.Mesh(legGeo, pantsMat);
           leftLeg.position.set(-(limbWidth / 2), -(torsoHeight / 2 + legHeight / 2), 0);
           player.add(leftLeg);
           const rightLeg = new THREE.Mesh(legGeo, pantsMat);
           rightLeg.position.set(limbWidth / 2, -(torsoHeight / 2 + legHeight / 2), 0);
           player.add(rightLeg);

            // Player group's origin is at the center of the torso
            scene.add(player);

            // Set initial position based on start platform (handled in resetGameStartConditions)
        }

        function createShadow() {
            const shadowGeo = new THREE.CircleGeometry(0.5, 16); // Simple circle shadow
            const shadowMat = new THREE.MeshBasicMaterial({ 
                color: 0x000000, 
                transparent: true, 
                opacity: 0.4 
            });
            shadowMesh = new THREE.Mesh(shadowGeo, shadowMat);
            shadowMesh.rotation.x = -Math.PI / 2; // Rotate to lie flat on the ground
            shadowMesh.position.y = -1.49; // Start slightly above milk initially
            shadowMesh.visible = false; // Start hidden until first update
            scene.add(shadowMesh);
        }

        function createBowl() {
            // Use LatheGeometry for a curved bowl shape
            const points = [];
            const segments = 10;
            const bowlHeight = 4; // Make it a bit deeper
            const topRadius = 10;
            const bottomRadius = 7;
            const curveDepth = 2; // How much it curves inwards at the bottom

            // Create points for the lathe profile (half cross-section)
            points.push(new THREE.Vector2(bottomRadius - curveDepth, -bowlHeight / 2)); // Inner bottom corner
            for (let i = 1; i <= segments; i++) {
                const t = i / segments;
                const angle = Math.PI / 2 * t; // Curve from bottom up
                const x = bottomRadius + curveDepth * Math.cos(angle);
                const y = -bowlHeight / 2 + (bowlHeight / 2 + 0.5) * Math.sin(angle); // +0.5 for slight lip
                points.push(new THREE.Vector2(x, y));
            }
             points.push(new THREE.Vector2(topRadius, bowlHeight / 2)); // Top outer edge
             points.push(new THREE.Vector2(topRadius + 0.2, bowlHeight / 2 + 0.1)); // Small lip outward
             points.push(new THREE.Vector2(topRadius + 0.2, bowlHeight / 2 + 0.3)); // Lip top edge
             points.push(new THREE.Vector2(topRadius - 0.3, bowlHeight / 2 + 0.3)); // Lip inner top edge
             points.push(new THREE.Vector2(topRadius - 0.5, bowlHeight / 2)); // Inner lip edge sloping down


            const bowlGeo = new THREE.LatheGeometry(points, 32); // Generate geometry by rotating points
            const bowlMat = new THREE.MeshLambertMaterial({ color: 0xe0e0e0, side: THREE.DoubleSide }); // Slightly darker grey
            bowl = new THREE.Mesh(bowlGeo, bowlMat);
            // Adjust position so the *bottom* of the bowl is near y=0, accounting for the new height
            bowl.position.y = 0.5; // Adjust as needed based on profile
            scene.add(bowl);
        }

         function createMilk() {
            // A flat plane or shallow cylinder inside the bowl for the milk
            const milkGeo = new THREE.CylinderGeometry(9.8, 9.8, 0.1, 32); // Slightly smaller radius than bowl, very short
            const milkMat = new THREE.MeshLambertMaterial({ color: 0xfffff0, transparent: true, opacity: 0.8 });
            milk = new THREE.Mesh(milkGeo, milkMat);
            milk.position.y = -1.4; // Just below the lip of the bowl, adjust as needed
            scene.add(milk);
         }

        function createPlatforms() {
            // Clear previous platforms if any exist
            platforms.forEach(p => scene.remove(p));
            if (startPlatform) scene.remove(startPlatform);
            if (finishPlatform) scene.remove(finishPlatform);
            platforms = []; // Clear existing platforms if restarting

            const platformGeo = new THREE.BoxGeometry(1.5, 0.2, 1.5); // Flat squares
            const startMat = new THREE.MeshLambertMaterial({ color: 0x00ff00 }); // Green for Start
            const finishMat = new THREE.MeshLambertMaterial({ color: 0xffd700 }); // Gold for Finish

            const bowlRadius = 9;
            const platformY = -1.0; // Base Y level for platforms

            // Create Start Platform
            startPlatform = new THREE.Mesh(platformGeo, startMat);
            // Move further inside the bowl to prevent clipping
            startPlatform.position.set(0, platformY, bowlRadius * 0.6); // Reduced multiplier from 0.75
            startPlatform.userData.isPlatform = true;
            startPlatform.userData.isStart = true;
            scene.add(startPlatform);
            platforms.push(startPlatform); // Add to general platforms for collision

            // Create Finish Platform
            finishPlatform = new THREE.Mesh(platformGeo, finishMat);
            // Move further inside the bowl, similar to start platform
            finishPlatform.position.set(0, platformY, -bowlRadius * 0.6); // Reduced multiplier from 0.9
            finishPlatform.userData.isPlatform = true;
            finishPlatform.userData.isFinish = true;
            scene.add(finishPlatform);
            platforms.push(finishPlatform); // Add to general platforms for collision

            // Randomly place intermediate platforms (Cereal Pieces)
            const numPlatforms = 18; // Increased cereal count by 50%
            // Create the cereal texture once
            const cerealTexture = createCerealTexture();
            // Use the texture in the material
            const platformBaseMaterial = new THREE.MeshLambertMaterial({ map: cerealTexture });
            // Make geometry thinner for cereal pieces
            const cerealGeo = new THREE.BoxGeometry(1.5, 0.1, 1.5); // Thinner height (was 0.2)

            const safeZone = 2.5; // Define the safe zone radius around start/finish platforms

            for (let i = 0; i < numPlatforms; i++) {
                // Use the new cereal geometry and the textured material
                const platform = new THREE.Mesh(cerealGeo.clone(), platformBaseMaterial); // No need to clone material if it's shared
                let placed = false;
                while (!placed) {
                    const angle = Math.random() * Math.PI * 2;
                    // Place between 20% and 80% of radius to avoid edges and center overlap
                    const radius = bowlRadius * 0.2 + Math.random() * bowlRadius * 0.6;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;

                    // Avoid placing too close to start/finish platform Z axis
                    if (Math.abs(z - startPlatform.position.z) > safeZone && Math.abs(z - finishPlatform.position.z) > safeZone) {
                         platform.position.set(
                             x,
                             platformY + Math.random() * 0.5 - 0.25, // Vary height slightly
                             z
                         );
                         placed = true;
                    }
                }

                platform.userData.isPlatform = true; // Tag for collision detection

                 // Add movement data for floating effect
                 platform.userData.moveDirection = new THREE.Vector3(
                     Math.random() - 0.5,
                     0, // Keep Y movement simple for now (bobbing)
                     Math.random() - 0.5
                 ).normalize();
                 platform.userData.moveSpeed = 0.1 + Math.random() * 0.4; // Slow speed
                 platform.userData.bobOffset = Math.random() * Math.PI * 2; // Random start for bobbing
                 platform.userData.baseY = platform.position.y;

                scene.add(platform);
                platforms.push(platform);
            }
        }

        function createSpoon() {
            spoon = new THREE.Group();
            const silverMat = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, metalness: 0.8, roughness: 0.3 }); // More metallic look

            // Handle - Use CapsuleGeometry for rounded ends
            const handleLength = 5.5;
            const handleRadius = 0.15;
            const handleGeo = new THREE.CapsuleGeometry(handleRadius, handleLength, 8, 16);
            const handle = new THREE.Mesh(handleGeo, silverMat);
            handle.rotation.x = Math.PI / 2; // Rotate to lie flat along Z
            handle.position.set(0, 0, -(handleLength / 2 + 0.5)); // Position relative to scoop center

            // Scoop - Use ShapeGeometry or ExtrudeGeometry for a better shape
            const scoopShape = new THREE.Shape();
            const scoopWidth = 1.2;
            const scoopLength = 1.8;
            const scoopDepth = 0.4; // How deep the scoop depression is

            // Define the 2D outline of the spoon scoop
            scoopShape.moveTo(-scoopWidth / 2, -scoopLength / 2);
            scoopShape.quadraticCurveTo(0, -scoopLength * 0.7, scoopWidth / 2, -scoopLength / 2); // Bottom curve
            scoopShape.lineTo(scoopWidth * 0.6, scoopLength / 2 * 0.8); // Taper towards handle
            scoopShape.quadraticCurveTo(0, scoopLength / 2, -scoopWidth * 0.6, scoopLength / 2 * 0.8); // Top curve near handle
            scoopShape.lineTo(-scoopWidth / 2, -scoopLength / 2); // Close shape

            // Extrude the shape slightly to give it thickness and a depression
            const extrudeSettings = {
                steps: 1,
                depth: 0.1, // Thickness of the metal
                bevelEnabled: true,
                bevelThickness: 0.05,
                bevelSize: 0.05,
                bevelOffset: 0,
                bevelSegments: 3
                // curveSegments could be added for smoother curves if needed
            };

            // We might need a different approach for the depression, maybe CSG or modeling software import.
            // For simplicity here, let's use a simpler geometry for the scoop base and add a depression manually or use a texture map.
            // Alternative: Use a shallow, scaled Sphere or Ellipsoid for the scoop part.

            // Let's stick to a scaled Sphere but make it shallower and wider.
            const scoopRadius = 1.0;
            const scoopGeo = new THREE.SphereGeometry(scoopRadius, 32, 16, 0, Math.PI * 2, 0, Math.PI * 0.6); // Less than hemisphere
            const scoop = new THREE.Mesh(scoopGeo, silverMat);
            scoop.scale.set(scoopWidth / (scoopRadius * 2), scoopDepth / scoopRadius, scoopLength / (scoopRadius * 2)); // Scale to desired dimensions
            // Adjust rotation for better isometric view (less steep angle)
            scoop.rotation.x = Math.PI * 0.45; // Was 0.55
            scoop.position.set(0, -0.1, 0); // Center the scoop

            spoon.add(handle);
            spoon.add(scoop);
            spoon.position.set(15, 5, 0); // Start off-screen
            scene.add(spoon);

            // Bounding box for collision - Adjust size based on new scoop/handle
            // Make it slightly larger than the visual scoop to be safe
            const colliderWidth = scoopWidth * 1.2;
            const colliderHeight = scoopDepth * 3; // Make taller to catch player better
            const colliderLength = scoopLength * 1.2;
            const spoonColliderGeo = new THREE.BoxGeometry(colliderWidth, colliderHeight, colliderLength);
            const spoonColliderMat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true, visible: debugMode });
            const spoonCollider = new THREE.Mesh(spoonColliderGeo, spoonColliderMat);
            spoonCollider.userData.isSpoon = true;
            // Position collider centered on the scoop visual
            spoonCollider.position.copy(scoop.position);
            spoon.add(spoonCollider); // Add collider to the spoon group
            spoon.userData.collider = spoonCollider;
        }

        // Collision Detection (AABB)
        function checkCollision(obj1, obj2) {
             // Ensure world matrices are updated for accurate bounding boxes
             obj1.updateMatrixWorld();
             obj2.updateMatrixWorld();

             // We need the collider of the spoon, not the whole spoon group
             const obj2Collider = (obj2 === spoon && spoon.userData.collider) ? spoon.userData.collider : obj2;

             const box1 = new THREE.Box3().setFromObject(obj1);
             const box2 = new THREE.Box3().setFromObject(obj2Collider);

             return box1.intersectsBox(box2);
        }

        function checkPlatformCollision(wasOnGroundPrev) { // Pass previous frame's ground state
            let landedThisFrame = false;
            const playerBox = new THREE.Box3().setFromObject(player);
            // Store previous Y position before applying velocity/gravity for collision check
            const previousPlayerFeetY = player.position.y - playerFeetOffset;
            // Apply vertical velocity *before* checking collision for this frame
            player.position.y += playerVelocity.y;
            const currentPlayerFeetY = player.position.y - playerFeetOffset;

            for (let i = 0; i < platforms.length; i++) {
                const platform = platforms[i];
                const platformBox = new THREE.Box3().setFromObject(platform);

                // Check if player is roughly above the platform horizontally
                if (playerBox.max.x > platformBox.min.x &&
                    playerBox.min.x < platformBox.max.x &&
                    playerBox.max.z > platformBox.min.z &&
                    playerBox.min.z < platformBox.max.z) {

                    // Improved Collision Check:
                    // Check if player was above the platform last frame, is now at or below it,
                    // and is moving downwards.
                    if (playerVelocity.y <= 0 && // Moving down or still
                        previousPlayerFeetY >= platformBox.max.y - 0.01 && // Was above or very close in previous step
                        currentPlayerFeetY <= platformBox.max.y + 0.01) { // Is now at or below (with tolerance)

                        // Collision detected!
                        player.position.y = platformBox.max.y + playerFeetOffset; // Correct position to be exactly on top
                        playerVelocity.y = 0; // Stop vertical movement
                        landedThisFrame = true;
                        onGround = true;
                        coyoteTimeRemaining = 0; // Reset coyote time
                        jumpsRemaining = 2; // Reset double jump on landing
                        // Check if this is the finish platform
                        if (platform.userData.isFinish) {
                            checkWinCondition(true); // Landed on finish platform
                        }
                        return; // Stop checking once landed on one platform
                    }
                }
            }

            // If loop finishes and player hasn't landed on any platform
            if (!landedThisFrame) {
                if (wasOnGroundPrev) { // If player was on ground last frame, start coyote time
                    coyoteTimeRemaining = coyoteTimeDuration;
                }
                onGround = false; // Update global state to not on ground
            }

            // Update global wasOnGround for the *next* frame
             wasOnGround = onGround;
        }

        function updatePlatformMovement(deltaTime) {
            // Use a smaller radius for boundary check to prevent clipping through the visual edge
            const effectiveBowlRadius = 8.5; // Reduced from visual radius (around 9.8-10)
            const bowlRadiusSq = effectiveBowlRadius * effectiveBowlRadius;
            const bobSpeed = 0.5;
            const bobAmount = 0.1;

            platforms.forEach(platform => {
                // Skip start and finish platforms
                if (platform.userData.isStart || platform.userData.isFinish) {
                    return;
                }

                // Bobbing motion (Y axis)
                platform.userData.bobOffset += bobSpeed * deltaTime;
                platform.position.y = platform.userData.baseY + Math.sin(platform.userData.bobOffset) * bobAmount;

                // Drifting motion (X and Z axes)
                const moveStep = platform.userData.moveDirection.clone().multiplyScalar(platform.userData.moveSpeed * deltaTime);
                platform.position.add(moveStep);

                // Boundary check (keep platforms within the bowl radius)
                const distSq = platform.position.x * platform.position.x + platform.position.z * platform.position.z;
                if (distSq > bowlRadiusSq) {
                    // If outside, reverse direction or redirect inwards
                    platform.userData.moveDirection.negate(); // Simple reversal
                    // Move back slightly to prevent getting stuck outside
                    platform.position.add(platform.userData.moveDirection.clone().multiplyScalar(0.1));
                }

                // Optional: Occasionally change direction slightly for more randomness
                if (Math.random() < 0.01) { // Low probability each frame
                     const randomRotation = new THREE.Euler(0, (Math.random() - 0.5) * 0.5, 0);
                     platform.userData.moveDirection.applyEuler(randomRotation);
                }
            });
        }

        function updateSpoon(deltaTime) {
            if (!spoon || !player) return;

            const spoonSpeed = 0.75 * deltaTime; // Further reduced speed
            const targetPosition = player.position.clone();
            targetPosition.y = Math.max(targetPosition.y, milk.position.y + 1.5); // Don't let spoon go too deep

            // Simple chase logic
            const direction = targetPosition.sub(spoon.position).normalize();
            spoon.position.add(direction.multiplyScalar(spoonSpeed));

            // Add some swooping motion (optional)
            spoon.position.y += Math.sin(Date.now() * 0.002) * 0.05;

            // Basic rotation towards player (optional)
            spoon.lookAt(player.position);
        }

        function checkWinCondition(landedOnFinish) {
            // Win if player has landed on the finish platform (checked in checkPlatformCollision)
            if (landedOnFinish) {
                gameWon = true;
                timerActive = false;
                const finalTime = (performance.now() - startTime) / 1000;
                currentTimeDisplay.textContent = finalTime.toFixed(2); // Show final time

                winMessage.style.display = 'block';
                checkAndRecordHighScore(finalTime);
                if (isMobile) restartButton.style.display = 'block'; // Show restart button on mobile
                 // Optionally stop animation or further updates
                 // cancelAnimationFrame(animate); // Could uncomment if we stop animate loop
            }
        }

        function checkLoseConditions() {
            // Lose if player falls into the milk
            const playerBox = new THREE.Box3().setFromObject(player);

            if (debugMode) {
                debugText.innerHTML = `Player Y min: ${playerBox.min.y.toFixed(2)}<br>Milk Y: ${milk.position.y.toFixed(2)}<br>Offset: ${playerFeetOffset.toFixed(2)}`;
            }

            // Calculate the bottom of the player model based on its position and feet offset
            const playerBottomY = player.position.y - playerFeetOffset;
            const milkTopY = milk.position.y + 0.05; // Slight threshold above milk

            if (playerBottomY < milkTopY) {
                 gameOver = true;
                 loseMessage.style.display = 'block';
                 if (isMobile) restartButton.style.display = 'block'; // Show restart button on mobile
                 return true;
            }

            // Lose if spoon collides with player
            if (spoon && spoon.userData.collider && checkCollision(player, spoon.userData.collider)) {
                 gameOver = true;
                 loseMessage.style.display = 'block';
                 if (isMobile) restartButton.style.display = 'block'; // Show restart button on mobile
                 return true;
            }
            return false;
        }

        const clock = new THREE.Clock(); // For deltaTime
        let accumulator = 0;
        const fixedTimeStep = 1 / 60; // Target 60 updates per second

        function updateGameLogic(deltaTime) {
             if (gameOver || gameWon) return;

            const wasOnGroundPrev = wasOnGround; // Store state before physics update

             // --- Coyote Time Countdown ---
             if (coyoteTimeRemaining > 0) {
                 coyoteTimeRemaining -= deltaTime;
             }

             // --- Player Movement ---
             // Handle keyboard input if not using alternative controls
             if (!isMobile) { // Desktop uses keyboard exclusively now
                 let rawInputX = 0;
                 let rawInputZ = 0;

                 if (keys['w'] || keys['arrowup']) {
                     rawInputZ -= 1;
                 }
                 if (keys['s'] || keys['arrowdown']) {
                     rawInputZ += 1;
                 }
                 if (keys['a'] || keys['arrowleft']) {
                     rawInputX -= 1;
                 }
                 if (keys['d'] || keys['arrowright']) {
                     rawInputX += 1;
                 }

                 // Normalize raw input if needed
                 const lengthSq = rawInputX * rawInputX + rawInputZ * rawInputZ;
                 if (lengthSq > 0) {
                     const length = Math.sqrt(lengthSq);
                     const normX = rawInputX / length;
                     const normZ = rawInputZ / length;

                     // Rotate the normalized input vector by -45 degrees to match isometric view
                     const factor = Math.sqrt(0.5);
                     const worldX = (normX - normZ) * factor;
                     const worldZ = (-normX - normZ) * factor; 
                     moveDirection.set(worldX, 0, worldZ);
                 } else {
                     moveDirection.set(0, 0, 0); // No input, stop moving
                 }
             }
             // For mobile, moveDirection is updated by joystick handlers
              // Ensure moveDirection is scaled by speed *after* joystick logic sets normalized direction
              const finalMove = moveDirection.clone().multiplyScalar(playerSpeed);


             // Normalize the move direction (whether from keyboard or joystick)
             if (moveDirection.lengthSq() > 0.0001) { // Use a small threshold
                 moveDirection.normalize();
             }

             // Apply movement relative to isometric view (adjust if needed)
             // This simple approach moves along world axes
             player.position.add(finalMove);


            // --- Player Physics & Jumping ---
            // Add character rotation to face movement direction (for mobile and keyboard)
            if (finalMove.lengthSq() > 0.001) {
                const targetRotation = Math.atan2(finalMove.x, finalMove.z);
                // Simple rotation - instantaneous
                player.rotation.y = targetRotation;
            }

            // Apply Gravity (with potential float modification)
            let currentGravity = gravity;

            // --- DEBUG LOG for Floating --- // TODO: Remove after debugging
            /*
            if (isMobile) { // Only log on mobile
                 console.log(`Float Check: jumpBtn=${jumpButtonPressed}, jumps=${jumpsRemaining}, velY=${playerVelocity.y.toFixed(3)}`);
            }
            */
            // --- END DEBUG ---

            // Apply float if jump is held AND player is moving down
            if ((isMobile && jumpButtonPressed || !isMobile && jumpKeyDown) && playerVelocity.y < 0) {
                // console.log("--- FLOATING ACTIVE ---"); // Debug log
                currentGravity *= floatFactor;
            }
            playerVelocity.y += currentGravity;

            // Vertical position update is now done *before* checkPlatformCollision
            // player.position.y += playerVelocity.y; // REMOVED FROM HERE

            checkPlatformCollision(wasOnGroundPrev); // Check for landing and reset jumps

            // Prevent falling through floor (basic check) - Check current position after collision correction
            if (player.position.y - playerFeetOffset < milk.position.y - 1) { // Well below milk?
                 if (!gameOver) {
                    console.warn("Player fell through floor unexpectedly.");
                    gameOver = true; // Trigger game over state
                    loseMessage.style.display = 'block';
                    if (isMobile) restartButton.style.display = 'block'; // Show restart button on mobile
                    timerActive = false;
                 }
            }

             // --- Spoon Logic ---
             updateSpoon(deltaTime);

             // --- Platform Movement ---
             updatePlatformMovement(deltaTime);

             // --- Collision & Win/Loss Checks ---
              if (checkLoseConditions()) {
                  return; // Stop further updates this frame if lost
              }
             // Win condition is checked within checkPlatformCollision

             // --- Update Shadow Position ---
             updateShadowPosition();
        }

        function updateShadowPosition() {
            if (!player || !shadowMesh) return;

            // Objects the shadow can be cast on (platforms + milk)
            const collidableObjects = [...platforms, milk]; 

            // Raycast down from slightly above the player's feet
            const rayOrigin = player.position.clone();
            rayOrigin.y += 0.1; // Start slightly above current pos to avoid self-intersection
            const rayDirection = new THREE.Vector3(0, -1, 0);
            raycaster.set(rayOrigin, rayDirection);

            const intersects = raycaster.intersectObjects(collidableObjects, false); // Don't check children

            if (intersects.length > 0) {
                // Find the closest intersection point
                const intersectionPoint = intersects[0].point;
                const distanceToGround = intersects[0].distance;

                shadowMesh.position.set(player.position.x, intersectionPoint.y + 0.01, player.position.z); // Position slightly above the hit surface
                shadowMesh.visible = true;

                // Optional: Scale shadow based on distance (subtle effect)
                const maxShadowDist = 3.0;
                const scaleFactor = Math.max(0.3, 1.0 - (distanceToGround / maxShadowDist));
                shadowMesh.scale.set(scaleFactor, scaleFactor, scaleFactor);
                 shadowMesh.material.opacity = Math.max(0.1, 0.4 * scaleFactor);

            } else {
                shadowMesh.visible = false; // Hide shadow if nothing is below within ray range
            }
        }

        function restartGame() {
            console.log("Restarting game...");

            // Recreate platforms in new positions
            createPlatforms();

            // Reset player position, velocity, jump state
             if (player) {
                 if (startPlatform) {
                     player.position.set(
                         startPlatform.position.x,
                         startPlatform.position.y + playerFeetOffset + 0.20, // Use consistent start height
                         startPlatform.position.z
                     );
                 } else {
                     player.position.set(0, 1 + playerFeetOffset, 8); // Fallback adjusted for offset
                 }
                 playerVelocity.set(0, 0, 0);
                 onGround = false; // Player starts slightly airborne
             } else {
                 createPlayer(); // Ensure player is created if missing
             }

            // Reset jump state
            jumpsRemaining = 2; // Give back double jump
            jumpKeyDown = false;
            coyoteTimeRemaining = 0; // Reset coyote timer
            wasOnGround = false; // Reset previous ground state tracker

            // Reset game state
            gameOver = false;
            gameWon = false;
            winMessage.style.display = 'none';
            loseMessage.style.display = 'none';
            recordMessage.style.display = 'none'; // Hide record message on restart
            restartButton.style.display = 'none'; // Hide restart button
            moveDirection.set(0, 0, 0); // Reset move direction
            if (isMobile) {
                resetJoystick();
                jumpButtonPressed = false;
            }

            // Reset spoon position/state
            if (spoon) {
                 spoon.position.set(15, 5, 0); // Reset spoon start position off-screen
             } else {
                 createSpoon(); // Ensure spoon is created
             }

            // Ensure other elements exist (might be called before init finishes fully)
             if (!bowl) createBowl();
             if (!milk) createMilk();

            // Start timer
            startTime = performance.now();
            timerActive = true;
            currentTimeDisplay.textContent = '0.00'; // Reset display

            // Resume animation loop is handled by the animate function structure
        }


        function playerJump() {
            // Assumes checks for jump availability (onGround, coyoteTime, jumpsRemaining)
            // are done *before* calling this function.
            playerVelocity.y = jumpStrength;
            jumpsRemaining--; 
            onGround = false; // Player is definitely airborne after any jump
            coyoteTimeRemaining = 0; // Consumed coyote time if used
        }

        function adjustCameraForMobile() {
            aspect = window.innerWidth / window.innerHeight;
            let viewSize = d;

            if (isMobile) {
                // Adjust zoom based on aspect ratio for mobile
                if (aspect < 0.6) { // Very tall/narrow (e.g., modern phones portrait)
                    viewSize = d * 0.65; 
                } else if (aspect < 1) { // Portrait or square
                    viewSize = d * 0.8;
                } else { // Landscape
                    viewSize = d * 0.85; // Zoom in slightly for landscape mobile
                }
                 // Optional: Slightly zoom out for landscape mobile if needed
                 // else {
                 //    viewSize = d * 1.1;
            }

            camera.left = -viewSize * aspect;
            camera.right = viewSize * aspect;
            camera.top = viewSize;
            camera.bottom = -viewSize;
            camera.updateProjectionMatrix();
        }

        function onWindowResize() {
            adjustCameraForMobile(); // Use the adjustment function
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            const key = event.key.toLowerCase();
            keys[key] = true;
             if ((gameOver || gameWon) && key === 'r') {
                 restartGame();
             }

            // Handle jump key press - only trigger once per press
            if ((key === ' ' || key === 'shift') && !jumpKeyDown) {
                if (jumpsRemaining > 0) { // Simplified check: Can we jump at all?
                    jumpKeyDown = true;
                    playerJump();
                }
            }

            // If any movement key is pressed, disable mouse controls
            if (['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(key)) {
                moveDirection.set(0, 0, 0); // Reset move direction
            }
        }

        function onKeyUp(event) {
             const key = event.key.toLowerCase();
             keys[key] = false;

            // Reset jump key flag
            if (key === ' ' || key === 'shift') {
                jumpKeyDown = false;
            }
        }

        function formatTime(timeSeconds) {
            return timeSeconds === Infinity ? '-.--' : timeSeconds.toFixed(2);
        }

        function updateHighScoreDisplay() {
            fastestTimeDisplay.textContent = formatTime(fastestTime);
            highScoreListDisplay.innerHTML = ''; // Clear existing list
            highScores.slice(0, MAX_HIGH_SCORES).forEach((score, index) => {
                const li = document.createElement('li');
                // Remove the manual index number, <ol> handles it
                li.textContent = `${formatTime(score)}s`; 
                highScoreListDisplay.appendChild(li);
            });
        }

        function checkAndRecordHighScore(currentTime) {
            let isNewRecord = false;
            if (currentTime < fastestTime) {
                fastestTime = currentTime;
                localStorage.setItem('coc_fastestTime', fastestTime);
                recordMessage.style.display = 'block'; // Show record message
                isNewRecord = true;

                // Trigger confetti!
                if (typeof confetti === 'function') {
                    confetti({
                        particleCount: 150,
                        spread: 90,
                        origin: { y: 0.6 } // Start confetti slightly below center
                    });
                }
            }

            // Add score to list, sort, and trim
            highScores.push(currentTime);
            highScores.sort((a, b) => a - b); // Sort ascending (fastest first)
            highScores = highScores.slice(0, MAX_HIGH_SCORES); // Keep only top N

            localStorage.setItem('coc_highScores', JSON.stringify(highScores));
            updateHighScoreDisplay();
            return isNewRecord;
        }

        // --- Mobile Control Handlers ---

        function isPointInsideRect(x, y, rect) {
            return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
        }

        function handleTouchStart(event) {
            event.preventDefault();
            const joystickRect = joystickBase.getBoundingClientRect();
            const jumpRect = jumpButton.getBoundingClientRect();

            // Determine joystick radius based on current base size (affected by CSS media queries)
            // Need to access computed style or rect, but rect is simpler here
            const currentJoystickRadius = joystickRect.width / 2;

            for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];

                // Check if touch is for joystick (and joystick isn't already controlled)
                if (joystickTouchId === null && isPointInsideRect(touch.clientX, touch.clientY, joystickRect)) {
                    joystickTouchId = touch.identifier;
                    joystickActive = true;
                    joystickCenter.x = joystickRect.left + joystickRect.width / 2;
                    joystickCenter.y = joystickRect.top + joystickRect.height / 2;
                    updateJoystickPosition(touch.clientX, touch.clientY, currentJoystickRadius); // Pass radius
                    // console.log("Joystick touch started:", joystickTouchId);
                }
                // Check if touch is for jump button (and jump isn't already controlled)
                else if (jumpButtonTouchId === null && isPointInsideRect(touch.clientX, touch.clientY, jumpRect)) {
                    if (jumpsRemaining > 0) { // Simplified check: Can we jump at all?
                        jumpButtonTouchId = touch.identifier;
                        jumpButtonPressed = true;
                        playerJump(); // Trigger jump
                        jumpButton.style.backgroundColor = 'rgba(0, 150, 0, 0.8)'; // Visual feedback
                        // console.log("Jump touch started:", jumpButtonTouchId);
                    }
                }
            }
        }

        function handleTouchMove(event) {
            // event.preventDefault(); // Prevent scrolling - Moved inside condition

            for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];

                // If this touch is the one controlling the joystick, update it and prevent default
                if (touch.identifier === joystickTouchId) {
                    event.preventDefault(); // Prevent scrolling only when joystick is moved
                    // Need the radius here too! Get it from the element again.
                    const currentJoystickRadius = joystickBase.getBoundingClientRect().width / 2;
                    updateJoystickPosition(touch.clientX, touch.clientY, currentJoystickRadius); // Pass radius
                    // console.log("Joystick touch moved:", joystickTouchId);
                    break; // Found the joystick touch, no need to check others in this loop
                }
            }
        }

        function handleTouchEnd(event) {
            event.preventDefault();

            for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];

                // Check if the ending touch was controlling the joystick
                if (touch.identifier === joystickTouchId) {
                    resetJoystick();
                    joystickTouchId = null;
                    // console.log("Joystick touch ended:", touch.identifier);
                }
                // Check if the ending touch was controlling the jump button
                else if (touch.identifier === jumpButtonTouchId) {
                    jumpButtonPressed = false;
                    jumpButtonTouchId = null;
                    jumpButton.style.backgroundColor = 'rgba(0, 200, 0, 0.6)'; // Restore visual
                    // console.log("Jump touch ended:", touch.identifier);
                }
            }
        }

        function updateJoystickPosition(clientX, clientY, radius) {
            let dx = clientX - joystickCenter.x;
            let dy = clientY - joystickCenter.y;
            let distance = Math.sqrt(dx * dx + dy * dy);

            // Clamp the nub position within the base radius
            if (distance > radius) {
                dx *= radius / distance;
                dy *= radius / distance;
                distance = radius;
            }

            // Update nub visual position (relative to base center)
            joystickNub.style.left = `calc(50% + ${dx}px)`;
            joystickNub.style.top = `calc(50% + ${dy}px)`;

            // Update game move direction based on joystick vector
            if (distance > 5) { // Dead zone
                // Convert joystick coords (dx, dy) to normalized screen coords (jx, jy) with Y pointing up
                const jx = dx / radius;
                const jy = -dy / radius; // Invert dy because screen Y is down

                // Rotate the input vector by -45 degrees to match isometric view
                // worldX = (jx - jy) / sqrt(2)
                // worldZ = (-jx - jy) / sqrt(2)
                const factor = Math.sqrt(0.5);
                const worldX = (jx - jy) * factor;
                const worldZ = (-jx - jy) * factor;

                moveDirection.set(worldX, 0, worldZ);
                // Normalization happens later before applying speed
            } else {
                moveDirection.set(0, 0, 0);
            }
        }

        function resetJoystick() {
            joystickActive = false;
            joystickNub.style.left = '50%';
            joystickNub.style.top = '50%';
            moveDirection.set(0, 0, 0); // Stop movement
        }

        function animate() {
            // Always request the next frame to keep the loop going, even if game over/won
            requestAnimationFrame(animate);

            // Calculate elapsed time since last frame
            const deltaTime = clock.getDelta();
            accumulator += deltaTime;

            // Run fixed updates based on accumulated time
            while (accumulator >= fixedTimeStep) {
                 // Only update game logic if game is active
                 if (!gameOver && !gameWon) {
                     updateGameLogic(fixedTimeStep); // Use fixed step for logic updates
                 }
                 accumulator -= fixedTimeStep;
            }

            // Render the scene (happens every frame)
            renderer.render(scene, camera);

            // Update Timer Display if active
            if (timerActive) {
                const elapsedTime = (performance.now() - startTime) / 1000;
                currentTimeDisplay.textContent = elapsedTime.toFixed(2);
            }
        }

        // Start the game
        init();

    </script>
</body>
</html> 
